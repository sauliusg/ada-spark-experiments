(* This file is generated by Why3's Coq driver *)
(* Beware! Only edit allowed sections below    *)
Require Import BuiltIn.
Require BuiltIn.
Require int.Int.
Require int.Abs.
Require int.EuclideanDivision.
Require int.ComputerDivision.
Require bool.Bool.

Axiom us_private : Type.
Parameter us_private_WhyType : WhyType us_private.
Existing Instance us_private_WhyType.

(* Why3 assumption *)
Definition us_fixed := Numbers.BinNums.Z.

Parameter private__bool_eq: us_private -> us_private -> Init.Datatypes.bool.

Parameter us_null_ext__: us_private.

Axiom us_type_of_heap : Type.
Parameter us_type_of_heap_WhyType : WhyType us_type_of_heap.
Existing Instance us_type_of_heap_WhyType.

(* Why3 assumption *)
Inductive us_type_of_heap__ref :=
  | us_type_of_heap__ref'mk : us_type_of_heap -> us_type_of_heap__ref.
Axiom us_type_of_heap__ref_WhyType : WhyType us_type_of_heap__ref.
Existing Instance us_type_of_heap__ref_WhyType.

(* Why3 assumption *)
Definition us_type_of_heap__content (v:us_type_of_heap__ref) :
    us_type_of_heap :=
  match v with
  | us_type_of_heap__ref'mk x => x
  end.

Axiom us_image : Type.
Parameter us_image_WhyType : WhyType us_image.
Existing Instance us_image_WhyType.

(* Why3 assumption *)
Inductive int__ref :=
  | int__ref'mk : Numbers.BinNums.Z -> int__ref.
Axiom int__ref_WhyType : WhyType int__ref.
Existing Instance int__ref_WhyType.

(* Why3 assumption *)
Definition int__content (v:int__ref) : Numbers.BinNums.Z :=
  match v with
  | int__ref'mk x => x
  end.

(* Why3 assumption *)
Inductive bool__ref :=
  | bool__ref'mk : Init.Datatypes.bool -> bool__ref.
Axiom bool__ref_WhyType : WhyType bool__ref.
Existing Instance bool__ref_WhyType.

(* Why3 assumption *)
Definition bool__content (v:bool__ref) : Init.Datatypes.bool :=
  match v with
  | bool__ref'mk x => x
  end.

(* Why3 assumption *)
Inductive us_fixed__ref :=
  | us_fixed__ref'mk : Numbers.BinNums.Z -> us_fixed__ref.
Axiom us_fixed__ref_WhyType : WhyType us_fixed__ref.
Existing Instance us_fixed__ref_WhyType.

(* Why3 assumption *)
Definition us_fixed__content (v:us_fixed__ref) : Numbers.BinNums.Z :=
  match v with
  | us_fixed__ref'mk x => x
  end.

(* Why3 assumption *)
Inductive real__ref :=
  | real__ref'mk : Reals.Rdefinitions.R -> real__ref.
Axiom real__ref_WhyType : WhyType real__ref.
Existing Instance real__ref_WhyType.

(* Why3 assumption *)
Definition real__content (v:real__ref) : Reals.Rdefinitions.R :=
  match v with
  | real__ref'mk x => x
  end.

(* Why3 assumption *)
Inductive us_private__ref :=
  | us_private__ref'mk : us_private -> us_private__ref.
Axiom us_private__ref_WhyType : WhyType us_private__ref.
Existing Instance us_private__ref_WhyType.

(* Why3 assumption *)
Definition us_private__content (v:us_private__ref) : us_private :=
  match v with
  | us_private__ref'mk x => x
  end.

(* Why3 assumption *)
Definition int__ref___projection (a:int__ref) : Numbers.BinNums.Z :=
  int__content a.

(* Why3 assumption *)
Definition us_fixed__ref___projection (a:us_fixed__ref) : Numbers.BinNums.Z :=
  us_fixed__content a.

(* Why3 assumption *)
Definition bool__ref___projection (a:bool__ref) : Init.Datatypes.bool :=
  bool__content a.

(* Why3 assumption *)
Definition real__ref___projection (a:real__ref) : Reals.Rdefinitions.R :=
  real__content a.

(* Why3 assumption *)
Definition us_private__ref___projection (a:us_private__ref) : us_private :=
  us_private__content a.

Axiom natural : Type.
Parameter natural_WhyType : WhyType natural.
Existing Instance natural_WhyType.

Parameter natural'int: natural -> Numbers.BinNums.Z.

Axiom natural'axiom :
  forall (i:natural),
  (0%Z <= (natural'int i))%Z /\ ((natural'int i) <= 2147483647%Z)%Z.

(* Why3 assumption *)
Definition in_range (x:Numbers.BinNums.Z) : Prop :=
  (0%Z <= x)%Z /\ (x <= 2147483647%Z)%Z.

Parameter bool_eq:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Axiom bool_eq'def :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  ((x = y) -> ((bool_eq x y) = Init.Datatypes.true)) /\
  (~ (x = y) -> ((bool_eq x y) = Init.Datatypes.false)).

Parameter attr__ATTRIBUTE_IMAGE: Numbers.BinNums.Z -> us_image.

Parameter attr__ATTRIBUTE_VALUE__pre_check: us_image -> Prop.

Parameter attr__ATTRIBUTE_VALUE: us_image -> Numbers.BinNums.Z.

Parameter user_eq: natural -> natural -> Init.Datatypes.bool.

Parameter dummy: natural.

(* Why3 assumption *)
Inductive natural__ref :=
  | natural__ref'mk : natural -> natural__ref.
Axiom natural__ref_WhyType : WhyType natural__ref.
Existing Instance natural__ref_WhyType.

(* Why3 assumption *)
Definition natural__content (v:natural__ref) : natural :=
  match v with
  | natural__ref'mk x => x
  end.

(* Why3 assumption *)
Definition natural__ref_natural__content__projection (a:natural__ref) :
    natural :=
  natural__content a.

(* Why3 assumption *)
Definition dynamic_invariant (temp___expr_46:Numbers.BinNums.Z)
    (temp___is_init_42:Init.Datatypes.bool)
    (temp___skip_constant_43:Init.Datatypes.bool)
    (temp___do_toplevel_44:Init.Datatypes.bool)
    (temp___do_typ_inv_45:Init.Datatypes.bool) : Prop :=
  (temp___is_init_42 = Init.Datatypes.true) \/ (0%Z <= 2147483647%Z)%Z ->
  in_range temp___expr_46.

Axiom positive : Type.
Parameter positive_WhyType : WhyType positive.
Existing Instance positive_WhyType.

Parameter positive'int: positive -> Numbers.BinNums.Z.

Axiom positive'axiom :
  forall (i:positive),
  (1%Z <= (positive'int i))%Z /\ ((positive'int i) <= 2147483647%Z)%Z.

(* Why3 assumption *)
Definition in_range1 (x:Numbers.BinNums.Z) : Prop :=
  (1%Z <= x)%Z /\ (x <= 2147483647%Z)%Z.

Parameter bool_eq1:
  Numbers.BinNums.Z -> Numbers.BinNums.Z -> Init.Datatypes.bool.

Axiom bool_eq'def1 :
  forall (x:Numbers.BinNums.Z) (y:Numbers.BinNums.Z),
  ((x = y) -> ((bool_eq1 x y) = Init.Datatypes.true)) /\
  (~ (x = y) -> ((bool_eq1 x y) = Init.Datatypes.false)).

Parameter attr__ATTRIBUTE_IMAGE1: Numbers.BinNums.Z -> us_image.

Parameter attr__ATTRIBUTE_VALUE__pre_check1: us_image -> Prop.

Parameter attr__ATTRIBUTE_VALUE1: us_image -> Numbers.BinNums.Z.

Parameter user_eq1: positive -> positive -> Init.Datatypes.bool.

Parameter dummy1: positive.

(* Why3 assumption *)
Inductive positive__ref :=
  | positive__ref'mk : positive -> positive__ref.
Axiom positive__ref_WhyType : WhyType positive__ref.
Existing Instance positive__ref_WhyType.

(* Why3 assumption *)
Definition positive__content (v:positive__ref) : positive :=
  match v with
  | positive__ref'mk x => x
  end.

(* Why3 assumption *)
Definition positive__ref_positive__content__projection (a:positive__ref) :
    positive :=
  positive__content a.

(* Why3 assumption *)
Definition dynamic_invariant1 (temp___expr_53:Numbers.BinNums.Z)
    (temp___is_init_49:Init.Datatypes.bool)
    (temp___skip_constant_50:Init.Datatypes.bool)
    (temp___do_toplevel_51:Init.Datatypes.bool)
    (temp___do_typ_inv_52:Init.Datatypes.bool) : Prop :=
  (temp___is_init_49 = Init.Datatypes.true) \/ (1%Z <= 2147483647%Z)%Z ->
  in_range1 temp___expr_53.

Parameter x: Numbers.BinNums.Z.

Parameter y: Numbers.BinNums.Z.

Parameter z: Numbers.BinNums.Z.

(* Why3 goal *)
Theorem def'vc :
  forall (r1:Numbers.BinNums.Z) (r2:Numbers.BinNums.Z),
  dynamic_invariant1 x Init.Datatypes.true Init.Datatypes.false
  Init.Datatypes.true Init.Datatypes.true ->
  dynamic_invariant1 y Init.Datatypes.true Init.Datatypes.false
  Init.Datatypes.true Init.Datatypes.true ->
  dynamic_invariant1 z Init.Datatypes.true Init.Datatypes.false
  Init.Datatypes.true Init.Datatypes.true ->
  dynamic_invariant r1 Init.Datatypes.false Init.Datatypes.false
  Init.Datatypes.true Init.Datatypes.true ->
  dynamic_invariant r2 Init.Datatypes.false Init.Datatypes.false
  Init.Datatypes.true Init.Datatypes.true -> (z < y)%Z ->
  forall (r11:Numbers.BinNums.Z), (r11 = (ZArith.BinInt.Z.quot x y)) ->
  forall (r21:Numbers.BinNums.Z), (r21 = (ZArith.BinInt.Z.quot x z)) ->
  (r11 <= r21)%Z.
Proof.
intros r1 r2 h1 h2 h3 h4 h5 h6 r11 h7 r21 h8.
subst.
SearchAbout Z.quot.
apply Z.quot_le_compat_l.
unfold dynamic_invariant1 in h1.
unfold in_range1 in h1.
apply Z.le_trans with (m:= 1%Z).
apply Z.le_0_1.
unfold dynamic_invariant1, in_range1 in h3.
apply h1.
left.
apply eq_refl.
unfold dynamic_invariant1, in_range1 in h3.
intuition.


Qed.

